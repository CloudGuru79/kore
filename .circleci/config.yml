---
version: 2.1

orbs:
  kube-orb: circleci/kubernetes@0.11.0

parameters:
  enable_e2e:
    type: boolean
    default: false
  enable_e2e_master:
    type: boolean
    default: false
  enable_gke_e2e:
    type: boolean
    default: true
  enable_eks_e2e:
    type: boolean
    default: true

jobs:
  build:
    environment:
      GOFLAGS: "-mod=vendor"
      USE_GIT_VERSION: "true"

    docker:
      - image: circleci/golang:1.14
      - name: database
        image: mariadb:bionic
        environment:
          MYSQL_ROOT_PASSWORD: pass
        command:
          sh -c "
            echo 'CREATE DATABASE IF NOT EXISTS kore;' > /docker-entrypoint-initdb.d/init.sql;
            /usr/local/bin/docker-entrypoint.sh --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci"

    steps:
      - checkout
      - run:
          name: Test
          environment:
            TEST_USERS_DATABASE_URL: "root:pass@tcp(database:3306)/kore?parseTime=true"
          command: |
            make test
      - run:
          name: Build
          command: |
            make build
      - persist_to_workspace:
          root: bin
          paths:
            - auth-proxy
            - kore-apiserver
            - kore-clusterappman
            - korectl
            - kore

  check-apis:
    environment:
      GOFLAGS: "-mod=vendor"
      USE_GIT_VERSION: "true"

    docker:
      - image: circleci/golang:1.14

      - name: etcd
        image: bitnami/etcd:latest
        environment:
          ALLOW_NONE_AUTHENTICATION: "yes"

      - name: database
        image: mariadb:bionic
        environment:
          MYSQL_ROOT_PASSWORD: pass
        command:
          sh -c "
            echo 'CREATE DATABASE IF NOT EXISTS kore;' > /docker-entrypoint-initdb.d/init.sql;
            /usr/local/bin/docker-entrypoint.sh --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci"

      - name: kube-controller-manager
        image: gcr.io/google-containers/kube-controller-manager-amd64:v1.15.11
        command:
          - /usr/local/bin/kube-controller-manager
          - --master=http://kube-apiserver:8080

      - name: kube-apiserver
        image: gcr.io/google-containers/kube-apiserver-amd64:v1.15.11
        command:
          - /usr/local/bin/kube-apiserver
          - --address=0.0.0.0
          - --alsologtostderr
          - --authorization-mode=RBAC
          - --bind-address=0.0.0.0
          - --default-watch-cache-size=200
          - --delete-collection-workers=10
          - --etcd-servers=http://etcd:2379
          - --log-flush-frequency=10s
          - --runtime-config=autoscaling/v1=false
          - --runtime-config=autoscaling/v2beta1=false
          - --runtime-config=autoscaling/v2beta2=false
          - --runtime-config=batch/v1=false
          - --runtime-config=batch/v1beta1=false
          - --runtime-config=networking.k8s.io/v1=false
          - --runtime-config=networking.k8s.io/v1beta1=false
          - --runtime-config=node.k8s.io/v1beta1=false

    steps:
      - checkout
      - run:
          name: Checking generated API resources
          command: |
            make check-apis
      - run:
          command: |
            make kore-apiserver
            bin/kore-apiserver --verbose
          background: true
          environment:
            KORE_ADMIN_TOKEN: "password"
            KORE_AUTHENTICATION_PLUGINS: "admintoken,localjwt"
            KORE_CERTIFICATE_AUTHORITY: "hack/ca/ca.pem"
            KORE_CERTIFICATE_AUTHORITY_KEY: "hack/ca/ca-key.pem"
            KORE_HMAC: "bdT2Qg6DybsLIwc0TbYWrkGC4auovscg"
            # The below must be matched with the private key in the API test project:
            KORE_LOCAL_JWT_PUBLIC_KEY: "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIG6XiNhkwDETU2zk0tGlI0DKlbEJcN4jxwJBqhd3neReLDnqg9SBgKepdy9Nxw5LAd1gNoBkLvdFJg9SbHlM0sCAwEAAQ=="
            KORE_UI_PUBLIC_URL: "http://localhost:3000"
            KUBE_API_SERVER: "http://kube-apiserver:8080"
            USERS_DB_URL: "root:pass@tcp(database:3306)/kore?parseTime=true"

      - run:
          name: Checking swagger
          command: |
            make swagger-json
            make swagger-validate
      - run:
          name: Integration testing API
          command: |
            make check-swagger-apiclient api-test

  release:
    environment:
      GOFLAGS: "-mod=vendor"

    docker:
      - image: circleci/golang:1.14

    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - deploy:
          command: |
            docker login -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} quay.io
            VERSION=${CIRCLE_SHA1} make images
            VERSION=${CIRCLE_TAG:-latest} make images
            VERSION=${CIRCLE_SHA1:-latest} make push-images
            VERSION=${CIRCLE_TAG:-latest} make push-images

  release-cli:
    environment:
      GOFLAGS: "-mod=vendor"

    docker:
      - image: circleci/golang:1.14

    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - attach_workspace:
          at: bin
      - deploy:
          command: |
            VERSION=${CIRCLE_TAG} make release-cli
            VERSION=${CIRCLE_TAG} make push-cli

  build-ui:
    docker:
      - image: node:12
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Testing UI
          working_directory: ~/project/ui
          command: |
            make test
      - run:
          name: Building UI
          working_directory: ~/project/ui
          command: |
            make build

  release-ui:
    environment:
      KORE_UI_IMAGE: quay.io/appvia/kore-ui
    docker:
      - image: docker:19.03-dind
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - deploy:
          name: Publishing UI to quay.io
          working_directory: ~/project/ui
          command: |
            docker login -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} quay.io
            docker build -t ${KORE_UI_IMAGE}:${CIRCLE_TAG:-latest} --build-arg version=${CIRCLE_TAG:-latest} .
            docker build -t ${KORE_UI_IMAGE}:${CIRCLE_SHA1} --build-arg version=${CIRCLE_SHA1} .
            docker push ${KORE_UI_IMAGE}:${CIRCLE_SHA1}
            docker push ${KORE_UI_IMAGE}:${CIRCLE_TAG:-latest}

  release-qa:
    docker:
      - image: alpine/helm:3.1.2
    steps:
      - checkout
      - run:
          name: Installing GNU
          command: |
            apk add bash coreutils curl --update
      - kube-orb/install-kubeconfig:
        kubeconfig: KUBECONFIG_DATA
      - run:
          name: Deploying to QA
          command: |
            echo "Deploying to QA"
            hack/deploy-qa.sh

  # This releases the local images for kore-apiserver and the auth-proxy; to
  # ensure we have a complete e2e
  e2e-images:
    docker:
      - image: circleci/golang:1.14
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Releasing E2E Images
          command: |
            docker login -u ${DOCKER_USER} -p ${DOCKER_PASSWORD} quay.io
            VERSION=${CIRCLE_SHA1} make images
            VERSION=${CIRCLE_SHA1} make push-images

  e2e:
    parameters:
      host:
        type: string
        default: http://127.0.0.1:10080

    environment:
      GOFLAGS: "-mod=vendor"
      KORE_API_PUBLIC_URL_QA: << parameters.host >>

    docker:
      - image: circleci/golang:1.14

      - name: etcd
        image: bitnami/etcd:latest
        environment:
          ALLOW_NONE_AUTHENTICATION: "yes"

      - name: database
        image: mariadb:bionic
        environment:
          MYSQL_ROOT_PASSWORD: pass
        command:
          sh -c "
            echo 'CREATE DATABASE IF NOT EXISTS kore;' > /docker-entrypoint-initdb.d/init.sql;
            /usr/local/bin/docker-entrypoint.sh --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci"

      - name: kube-controller-manager
        image: gcr.io/google-containers/kube-controller-manager-amd64:v1.15.11
        command:
          - /usr/local/bin/kube-controller-manager
          - --master=http://kube-apiserver:8080

      - name: kube-apiserver
        image: gcr.io/google-containers/kube-apiserver-amd64:v1.15.11
        command:
          - /usr/local/bin/kube-apiserver
          - --address=0.0.0.0
          - --alsologtostderr
          - --authorization-mode=RBAC
          - --bind-address=0.0.0.0
          - --default-watch-cache-size=200
          - --delete-collection-workers=10
          - --etcd-servers=http://etcd:2379
          - --log-flush-frequency=10s
          - --runtime-config=autoscaling/v1=false
          - --runtime-config=autoscaling/v2beta1=false
          - --runtime-config=autoscaling/v2beta2=false
          - --runtime-config=batch/v1=false
          - --runtime-config=batch/v1beta1=false
          - --runtime-config=networking.k8s.io/v1=false
          - --runtime-config=networking.k8s.io/v1beta1=false
          - --runtime-config=node.k8s.io/v1beta1=false

    steps:
      - checkout
      - run:
          name: Building binaries
          command: |
            make kore-apiserver
            make korectl
            sudo mv bin/korectl /bin
      - run:
          name: Running the Kore API
          command: |
            export AUTH_PROXY_IMAGE="quay.io/appvia/auth-proxy:${CIRCLE_SHA1}"
            export CLUSTERAPPMAN_IMAGE="quay.io/appvia/kore-apiserver:${CIRCLE_SHA1}"
            bin/kore-apiserver --disable-json-logging --verbose
          background: true
          environment:
            KORE_ADMIN_TOKEN: "password"
            KORE_AUTHENTICATION_PLUGINS: "admintoken,openid"
            KORE_CERTIFICATE_AUTHORITY: "hack/ca/ca.pem"
            KORE_CERTIFICATE_AUTHORITY_KEY: "hack/ca/ca-key.pem"
            KORE_HMAC: "bdT2Qg6DybsLIwc0TbYWrkGC4auovscg"
            KORE_UI_PUBLIC_URL: "http://localhost:3000"
            KUBE_API_SERVER: "http://kube-apiserver:8080"
            USERS_DB_URL: "root:pass@tcp(database:3306)/kore?parseTime=true"
      - run:
          name: Installing tools
          command: |
            sudo apt install -y bash bats curl jq
      - run:
          name: Installing kubectl
          command: |
            sudo curl -sL https://storage.googleapis.com/kubernetes-release/release/v1.15.11/bin/linux/amd64/kubectl -o /bin/kubectl
            sudo chmod +x /bin/kubectl
      - run:
          name: Waiting for API
          command: |
            curl -s \
              --retry 10 \
              --retry-connrefused \
              --retry-delay 5 \
              ${KORE_API_PUBLIC_URL_QA}/healthz
      - run:
          name: Running E2E Suite
          environment:
            KORE_ADMIN_TOKEN: "password"
          command: |
            test/e2e/check-suite.sh --enable-e2e-user ${KORE_E2E_USER}

workflows:
  version: 2.1
  workflow:
    unless: << pipeline.parameters.enable_e2e >>
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*$/
      - check-apis:
          filters:
            tags:
              only: /^v.*$/
      - release:
          requires:
            - build
            - check-apis
          filters:
            branches:
              only: master
            tags:
              only: /^v.*$/
      - release-cli:
          requires:
            - build
            - check-apis
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^v.*$/
      - build-ui:
          filters:
            tags:
              only: /^v.*$/
      - release-ui:
          filters:
            branches:
              only: master
            tags:
              only: /^v.*$/
          requires:
            - build-ui
      - release-qa:
          filters:
            branches:
              only: master
          requires:
            - release
            - release-ui

  e2e:
    when: << pipeline.parameters.enable_e2e >>
    jobs:
      - e2e-images:
          filters:
            branches:
              ignore: master

      - e2e:
          filters:
            branches:
              ignore: master
          requires:
            - e2e-images

  e2e_master:
    when: << pipeline.parameters.enable_e2e_master >>
    jobs:
      - e2e:
          filters:
            branches:
              only: master
