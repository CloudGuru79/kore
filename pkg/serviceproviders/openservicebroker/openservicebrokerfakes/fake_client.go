// Code generated by counterfeiter. DO NOT EDIT.
package openservicebrokerfakes

import (
	"sync"

	"github.com/appvia/kore/pkg/serviceproviders/openservicebroker"
	v2 "github.com/kubernetes-sigs/go-open-service-broker-client/v2"
)

type FakeClient struct {
	BindStub        func(*v2.BindRequest) (*v2.BindResponse, error)
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		arg1 *v2.BindRequest
	}
	bindReturns struct {
		result1 *v2.BindResponse
		result2 error
	}
	bindReturnsOnCall map[int]struct {
		result1 *v2.BindResponse
		result2 error
	}
	DeprovisionInstanceStub        func(*v2.DeprovisionRequest) (*v2.DeprovisionResponse, error)
	deprovisionInstanceMutex       sync.RWMutex
	deprovisionInstanceArgsForCall []struct {
		arg1 *v2.DeprovisionRequest
	}
	deprovisionInstanceReturns struct {
		result1 *v2.DeprovisionResponse
		result2 error
	}
	deprovisionInstanceReturnsOnCall map[int]struct {
		result1 *v2.DeprovisionResponse
		result2 error
	}
	GetBindingStub        func(*v2.GetBindingRequest) (*v2.GetBindingResponse, error)
	getBindingMutex       sync.RWMutex
	getBindingArgsForCall []struct {
		arg1 *v2.GetBindingRequest
	}
	getBindingReturns struct {
		result1 *v2.GetBindingResponse
		result2 error
	}
	getBindingReturnsOnCall map[int]struct {
		result1 *v2.GetBindingResponse
		result2 error
	}
	GetCatalogStub        func() (*v2.CatalogResponse, error)
	getCatalogMutex       sync.RWMutex
	getCatalogArgsForCall []struct {
	}
	getCatalogReturns struct {
		result1 *v2.CatalogResponse
		result2 error
	}
	getCatalogReturnsOnCall map[int]struct {
		result1 *v2.CatalogResponse
		result2 error
	}
	GetInstanceStub        func(*v2.GetInstanceRequest) (*v2.GetInstanceResponse, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 *v2.GetInstanceRequest
	}
	getInstanceReturns struct {
		result1 *v2.GetInstanceResponse
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *v2.GetInstanceResponse
		result2 error
	}
	PollBindingLastOperationStub        func(*v2.BindingLastOperationRequest) (*v2.LastOperationResponse, error)
	pollBindingLastOperationMutex       sync.RWMutex
	pollBindingLastOperationArgsForCall []struct {
		arg1 *v2.BindingLastOperationRequest
	}
	pollBindingLastOperationReturns struct {
		result1 *v2.LastOperationResponse
		result2 error
	}
	pollBindingLastOperationReturnsOnCall map[int]struct {
		result1 *v2.LastOperationResponse
		result2 error
	}
	PollLastOperationStub        func(*v2.LastOperationRequest) (*v2.LastOperationResponse, error)
	pollLastOperationMutex       sync.RWMutex
	pollLastOperationArgsForCall []struct {
		arg1 *v2.LastOperationRequest
	}
	pollLastOperationReturns struct {
		result1 *v2.LastOperationResponse
		result2 error
	}
	pollLastOperationReturnsOnCall map[int]struct {
		result1 *v2.LastOperationResponse
		result2 error
	}
	ProvisionInstanceStub        func(*v2.ProvisionRequest) (*v2.ProvisionResponse, error)
	provisionInstanceMutex       sync.RWMutex
	provisionInstanceArgsForCall []struct {
		arg1 *v2.ProvisionRequest
	}
	provisionInstanceReturns struct {
		result1 *v2.ProvisionResponse
		result2 error
	}
	provisionInstanceReturnsOnCall map[int]struct {
		result1 *v2.ProvisionResponse
		result2 error
	}
	UnbindStub        func(*v2.UnbindRequest) (*v2.UnbindResponse, error)
	unbindMutex       sync.RWMutex
	unbindArgsForCall []struct {
		arg1 *v2.UnbindRequest
	}
	unbindReturns struct {
		result1 *v2.UnbindResponse
		result2 error
	}
	unbindReturnsOnCall map[int]struct {
		result1 *v2.UnbindResponse
		result2 error
	}
	UpdateInstanceStub        func(*v2.UpdateInstanceRequest) (*v2.UpdateInstanceResponse, error)
	updateInstanceMutex       sync.RWMutex
	updateInstanceArgsForCall []struct {
		arg1 *v2.UpdateInstanceRequest
	}
	updateInstanceReturns struct {
		result1 *v2.UpdateInstanceResponse
		result2 error
	}
	updateInstanceReturnsOnCall map[int]struct {
		result1 *v2.UpdateInstanceResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Bind(arg1 *v2.BindRequest) (*v2.BindResponse, error) {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		arg1 *v2.BindRequest
	}{arg1})
	fake.recordInvocation("Bind", []interface{}{arg1})
	fake.bindMutex.Unlock()
	if fake.BindStub != nil {
		return fake.BindStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.bindReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakeClient) BindCalls(stub func(*v2.BindRequest) (*v2.BindResponse, error)) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = stub
}

func (fake *FakeClient) BindArgsForCall(i int) *v2.BindRequest {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	argsForCall := fake.bindArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) BindReturns(result1 *v2.BindResponse, result2 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 *v2.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BindReturnsOnCall(i int, result1 *v2.BindResponse, result2 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 *v2.BindResponse
			result2 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 *v2.BindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeprovisionInstance(arg1 *v2.DeprovisionRequest) (*v2.DeprovisionResponse, error) {
	fake.deprovisionInstanceMutex.Lock()
	ret, specificReturn := fake.deprovisionInstanceReturnsOnCall[len(fake.deprovisionInstanceArgsForCall)]
	fake.deprovisionInstanceArgsForCall = append(fake.deprovisionInstanceArgsForCall, struct {
		arg1 *v2.DeprovisionRequest
	}{arg1})
	fake.recordInvocation("DeprovisionInstance", []interface{}{arg1})
	fake.deprovisionInstanceMutex.Unlock()
	if fake.DeprovisionInstanceStub != nil {
		return fake.DeprovisionInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deprovisionInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeprovisionInstanceCallCount() int {
	fake.deprovisionInstanceMutex.RLock()
	defer fake.deprovisionInstanceMutex.RUnlock()
	return len(fake.deprovisionInstanceArgsForCall)
}

func (fake *FakeClient) DeprovisionInstanceCalls(stub func(*v2.DeprovisionRequest) (*v2.DeprovisionResponse, error)) {
	fake.deprovisionInstanceMutex.Lock()
	defer fake.deprovisionInstanceMutex.Unlock()
	fake.DeprovisionInstanceStub = stub
}

func (fake *FakeClient) DeprovisionInstanceArgsForCall(i int) *v2.DeprovisionRequest {
	fake.deprovisionInstanceMutex.RLock()
	defer fake.deprovisionInstanceMutex.RUnlock()
	argsForCall := fake.deprovisionInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeprovisionInstanceReturns(result1 *v2.DeprovisionResponse, result2 error) {
	fake.deprovisionInstanceMutex.Lock()
	defer fake.deprovisionInstanceMutex.Unlock()
	fake.DeprovisionInstanceStub = nil
	fake.deprovisionInstanceReturns = struct {
		result1 *v2.DeprovisionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeprovisionInstanceReturnsOnCall(i int, result1 *v2.DeprovisionResponse, result2 error) {
	fake.deprovisionInstanceMutex.Lock()
	defer fake.deprovisionInstanceMutex.Unlock()
	fake.DeprovisionInstanceStub = nil
	if fake.deprovisionInstanceReturnsOnCall == nil {
		fake.deprovisionInstanceReturnsOnCall = make(map[int]struct {
			result1 *v2.DeprovisionResponse
			result2 error
		})
	}
	fake.deprovisionInstanceReturnsOnCall[i] = struct {
		result1 *v2.DeprovisionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBinding(arg1 *v2.GetBindingRequest) (*v2.GetBindingResponse, error) {
	fake.getBindingMutex.Lock()
	ret, specificReturn := fake.getBindingReturnsOnCall[len(fake.getBindingArgsForCall)]
	fake.getBindingArgsForCall = append(fake.getBindingArgsForCall, struct {
		arg1 *v2.GetBindingRequest
	}{arg1})
	fake.recordInvocation("GetBinding", []interface{}{arg1})
	fake.getBindingMutex.Unlock()
	if fake.GetBindingStub != nil {
		return fake.GetBindingStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBindingReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetBindingCallCount() int {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	return len(fake.getBindingArgsForCall)
}

func (fake *FakeClient) GetBindingCalls(stub func(*v2.GetBindingRequest) (*v2.GetBindingResponse, error)) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = stub
}

func (fake *FakeClient) GetBindingArgsForCall(i int) *v2.GetBindingRequest {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	argsForCall := fake.getBindingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetBindingReturns(result1 *v2.GetBindingResponse, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	fake.getBindingReturns = struct {
		result1 *v2.GetBindingResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBindingReturnsOnCall(i int, result1 *v2.GetBindingResponse, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	if fake.getBindingReturnsOnCall == nil {
		fake.getBindingReturnsOnCall = make(map[int]struct {
			result1 *v2.GetBindingResponse
			result2 error
		})
	}
	fake.getBindingReturnsOnCall[i] = struct {
		result1 *v2.GetBindingResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetCatalog() (*v2.CatalogResponse, error) {
	fake.getCatalogMutex.Lock()
	ret, specificReturn := fake.getCatalogReturnsOnCall[len(fake.getCatalogArgsForCall)]
	fake.getCatalogArgsForCall = append(fake.getCatalogArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCatalog", []interface{}{})
	fake.getCatalogMutex.Unlock()
	if fake.GetCatalogStub != nil {
		return fake.GetCatalogStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCatalogReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetCatalogCallCount() int {
	fake.getCatalogMutex.RLock()
	defer fake.getCatalogMutex.RUnlock()
	return len(fake.getCatalogArgsForCall)
}

func (fake *FakeClient) GetCatalogCalls(stub func() (*v2.CatalogResponse, error)) {
	fake.getCatalogMutex.Lock()
	defer fake.getCatalogMutex.Unlock()
	fake.GetCatalogStub = stub
}

func (fake *FakeClient) GetCatalogReturns(result1 *v2.CatalogResponse, result2 error) {
	fake.getCatalogMutex.Lock()
	defer fake.getCatalogMutex.Unlock()
	fake.GetCatalogStub = nil
	fake.getCatalogReturns = struct {
		result1 *v2.CatalogResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetCatalogReturnsOnCall(i int, result1 *v2.CatalogResponse, result2 error) {
	fake.getCatalogMutex.Lock()
	defer fake.getCatalogMutex.Unlock()
	fake.GetCatalogStub = nil
	if fake.getCatalogReturnsOnCall == nil {
		fake.getCatalogReturnsOnCall = make(map[int]struct {
			result1 *v2.CatalogResponse
			result2 error
		})
	}
	fake.getCatalogReturnsOnCall[i] = struct {
		result1 *v2.CatalogResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstance(arg1 *v2.GetInstanceRequest) (*v2.GetInstanceResponse, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 *v2.GetInstanceRequest
	}{arg1})
	fake.recordInvocation("GetInstance", []interface{}{arg1})
	fake.getInstanceMutex.Unlock()
	if fake.GetInstanceStub != nil {
		return fake.GetInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeClient) GetInstanceCalls(stub func(*v2.GetInstanceRequest) (*v2.GetInstanceResponse, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeClient) GetInstanceArgsForCall(i int) *v2.GetInstanceRequest {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetInstanceReturns(result1 *v2.GetInstanceResponse, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *v2.GetInstanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceReturnsOnCall(i int, result1 *v2.GetInstanceResponse, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *v2.GetInstanceResponse
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *v2.GetInstanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PollBindingLastOperation(arg1 *v2.BindingLastOperationRequest) (*v2.LastOperationResponse, error) {
	fake.pollBindingLastOperationMutex.Lock()
	ret, specificReturn := fake.pollBindingLastOperationReturnsOnCall[len(fake.pollBindingLastOperationArgsForCall)]
	fake.pollBindingLastOperationArgsForCall = append(fake.pollBindingLastOperationArgsForCall, struct {
		arg1 *v2.BindingLastOperationRequest
	}{arg1})
	fake.recordInvocation("PollBindingLastOperation", []interface{}{arg1})
	fake.pollBindingLastOperationMutex.Unlock()
	if fake.PollBindingLastOperationStub != nil {
		return fake.PollBindingLastOperationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pollBindingLastOperationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PollBindingLastOperationCallCount() int {
	fake.pollBindingLastOperationMutex.RLock()
	defer fake.pollBindingLastOperationMutex.RUnlock()
	return len(fake.pollBindingLastOperationArgsForCall)
}

func (fake *FakeClient) PollBindingLastOperationCalls(stub func(*v2.BindingLastOperationRequest) (*v2.LastOperationResponse, error)) {
	fake.pollBindingLastOperationMutex.Lock()
	defer fake.pollBindingLastOperationMutex.Unlock()
	fake.PollBindingLastOperationStub = stub
}

func (fake *FakeClient) PollBindingLastOperationArgsForCall(i int) *v2.BindingLastOperationRequest {
	fake.pollBindingLastOperationMutex.RLock()
	defer fake.pollBindingLastOperationMutex.RUnlock()
	argsForCall := fake.pollBindingLastOperationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PollBindingLastOperationReturns(result1 *v2.LastOperationResponse, result2 error) {
	fake.pollBindingLastOperationMutex.Lock()
	defer fake.pollBindingLastOperationMutex.Unlock()
	fake.PollBindingLastOperationStub = nil
	fake.pollBindingLastOperationReturns = struct {
		result1 *v2.LastOperationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PollBindingLastOperationReturnsOnCall(i int, result1 *v2.LastOperationResponse, result2 error) {
	fake.pollBindingLastOperationMutex.Lock()
	defer fake.pollBindingLastOperationMutex.Unlock()
	fake.PollBindingLastOperationStub = nil
	if fake.pollBindingLastOperationReturnsOnCall == nil {
		fake.pollBindingLastOperationReturnsOnCall = make(map[int]struct {
			result1 *v2.LastOperationResponse
			result2 error
		})
	}
	fake.pollBindingLastOperationReturnsOnCall[i] = struct {
		result1 *v2.LastOperationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PollLastOperation(arg1 *v2.LastOperationRequest) (*v2.LastOperationResponse, error) {
	fake.pollLastOperationMutex.Lock()
	ret, specificReturn := fake.pollLastOperationReturnsOnCall[len(fake.pollLastOperationArgsForCall)]
	fake.pollLastOperationArgsForCall = append(fake.pollLastOperationArgsForCall, struct {
		arg1 *v2.LastOperationRequest
	}{arg1})
	fake.recordInvocation("PollLastOperation", []interface{}{arg1})
	fake.pollLastOperationMutex.Unlock()
	if fake.PollLastOperationStub != nil {
		return fake.PollLastOperationStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.pollLastOperationReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PollLastOperationCallCount() int {
	fake.pollLastOperationMutex.RLock()
	defer fake.pollLastOperationMutex.RUnlock()
	return len(fake.pollLastOperationArgsForCall)
}

func (fake *FakeClient) PollLastOperationCalls(stub func(*v2.LastOperationRequest) (*v2.LastOperationResponse, error)) {
	fake.pollLastOperationMutex.Lock()
	defer fake.pollLastOperationMutex.Unlock()
	fake.PollLastOperationStub = stub
}

func (fake *FakeClient) PollLastOperationArgsForCall(i int) *v2.LastOperationRequest {
	fake.pollLastOperationMutex.RLock()
	defer fake.pollLastOperationMutex.RUnlock()
	argsForCall := fake.pollLastOperationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) PollLastOperationReturns(result1 *v2.LastOperationResponse, result2 error) {
	fake.pollLastOperationMutex.Lock()
	defer fake.pollLastOperationMutex.Unlock()
	fake.PollLastOperationStub = nil
	fake.pollLastOperationReturns = struct {
		result1 *v2.LastOperationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PollLastOperationReturnsOnCall(i int, result1 *v2.LastOperationResponse, result2 error) {
	fake.pollLastOperationMutex.Lock()
	defer fake.pollLastOperationMutex.Unlock()
	fake.PollLastOperationStub = nil
	if fake.pollLastOperationReturnsOnCall == nil {
		fake.pollLastOperationReturnsOnCall = make(map[int]struct {
			result1 *v2.LastOperationResponse
			result2 error
		})
	}
	fake.pollLastOperationReturnsOnCall[i] = struct {
		result1 *v2.LastOperationResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ProvisionInstance(arg1 *v2.ProvisionRequest) (*v2.ProvisionResponse, error) {
	fake.provisionInstanceMutex.Lock()
	ret, specificReturn := fake.provisionInstanceReturnsOnCall[len(fake.provisionInstanceArgsForCall)]
	fake.provisionInstanceArgsForCall = append(fake.provisionInstanceArgsForCall, struct {
		arg1 *v2.ProvisionRequest
	}{arg1})
	fake.recordInvocation("ProvisionInstance", []interface{}{arg1})
	fake.provisionInstanceMutex.Unlock()
	if fake.ProvisionInstanceStub != nil {
		return fake.ProvisionInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.provisionInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ProvisionInstanceCallCount() int {
	fake.provisionInstanceMutex.RLock()
	defer fake.provisionInstanceMutex.RUnlock()
	return len(fake.provisionInstanceArgsForCall)
}

func (fake *FakeClient) ProvisionInstanceCalls(stub func(*v2.ProvisionRequest) (*v2.ProvisionResponse, error)) {
	fake.provisionInstanceMutex.Lock()
	defer fake.provisionInstanceMutex.Unlock()
	fake.ProvisionInstanceStub = stub
}

func (fake *FakeClient) ProvisionInstanceArgsForCall(i int) *v2.ProvisionRequest {
	fake.provisionInstanceMutex.RLock()
	defer fake.provisionInstanceMutex.RUnlock()
	argsForCall := fake.provisionInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ProvisionInstanceReturns(result1 *v2.ProvisionResponse, result2 error) {
	fake.provisionInstanceMutex.Lock()
	defer fake.provisionInstanceMutex.Unlock()
	fake.ProvisionInstanceStub = nil
	fake.provisionInstanceReturns = struct {
		result1 *v2.ProvisionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ProvisionInstanceReturnsOnCall(i int, result1 *v2.ProvisionResponse, result2 error) {
	fake.provisionInstanceMutex.Lock()
	defer fake.provisionInstanceMutex.Unlock()
	fake.ProvisionInstanceStub = nil
	if fake.provisionInstanceReturnsOnCall == nil {
		fake.provisionInstanceReturnsOnCall = make(map[int]struct {
			result1 *v2.ProvisionResponse
			result2 error
		})
	}
	fake.provisionInstanceReturnsOnCall[i] = struct {
		result1 *v2.ProvisionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Unbind(arg1 *v2.UnbindRequest) (*v2.UnbindResponse, error) {
	fake.unbindMutex.Lock()
	ret, specificReturn := fake.unbindReturnsOnCall[len(fake.unbindArgsForCall)]
	fake.unbindArgsForCall = append(fake.unbindArgsForCall, struct {
		arg1 *v2.UnbindRequest
	}{arg1})
	fake.recordInvocation("Unbind", []interface{}{arg1})
	fake.unbindMutex.Unlock()
	if fake.UnbindStub != nil {
		return fake.UnbindStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unbindReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UnbindCallCount() int {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	return len(fake.unbindArgsForCall)
}

func (fake *FakeClient) UnbindCalls(stub func(*v2.UnbindRequest) (*v2.UnbindResponse, error)) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = stub
}

func (fake *FakeClient) UnbindArgsForCall(i int) *v2.UnbindRequest {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	argsForCall := fake.unbindArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UnbindReturns(result1 *v2.UnbindResponse, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	fake.unbindReturns = struct {
		result1 *v2.UnbindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UnbindReturnsOnCall(i int, result1 *v2.UnbindResponse, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	if fake.unbindReturnsOnCall == nil {
		fake.unbindReturnsOnCall = make(map[int]struct {
			result1 *v2.UnbindResponse
			result2 error
		})
	}
	fake.unbindReturnsOnCall[i] = struct {
		result1 *v2.UnbindResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateInstance(arg1 *v2.UpdateInstanceRequest) (*v2.UpdateInstanceResponse, error) {
	fake.updateInstanceMutex.Lock()
	ret, specificReturn := fake.updateInstanceReturnsOnCall[len(fake.updateInstanceArgsForCall)]
	fake.updateInstanceArgsForCall = append(fake.updateInstanceArgsForCall, struct {
		arg1 *v2.UpdateInstanceRequest
	}{arg1})
	fake.recordInvocation("UpdateInstance", []interface{}{arg1})
	fake.updateInstanceMutex.Unlock()
	if fake.UpdateInstanceStub != nil {
		return fake.UpdateInstanceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateInstanceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateInstanceCallCount() int {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	return len(fake.updateInstanceArgsForCall)
}

func (fake *FakeClient) UpdateInstanceCalls(stub func(*v2.UpdateInstanceRequest) (*v2.UpdateInstanceResponse, error)) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = stub
}

func (fake *FakeClient) UpdateInstanceArgsForCall(i int) *v2.UpdateInstanceRequest {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	argsForCall := fake.updateInstanceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpdateInstanceReturns(result1 *v2.UpdateInstanceResponse, result2 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	fake.updateInstanceReturns = struct {
		result1 *v2.UpdateInstanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateInstanceReturnsOnCall(i int, result1 *v2.UpdateInstanceResponse, result2 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	if fake.updateInstanceReturnsOnCall == nil {
		fake.updateInstanceReturnsOnCall = make(map[int]struct {
			result1 *v2.UpdateInstanceResponse
			result2 error
		})
	}
	fake.updateInstanceReturnsOnCall[i] = struct {
		result1 *v2.UpdateInstanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.deprovisionInstanceMutex.RLock()
	defer fake.deprovisionInstanceMutex.RUnlock()
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	fake.getCatalogMutex.RLock()
	defer fake.getCatalogMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.pollBindingLastOperationMutex.RLock()
	defer fake.pollBindingLastOperationMutex.RUnlock()
	fake.pollLastOperationMutex.RLock()
	defer fake.pollLastOperationMutex.RUnlock()
	fake.provisionInstanceMutex.RLock()
	defer fake.provisionInstanceMutex.RUnlock()
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openservicebroker.Client = new(FakeClient)
